from typing import List

from common import solve


def get_solution(input_lines: List[str]) -> List[str]:
    """
    Сортирует массив чисел с помощью сортировки слиянием и выводит информацию о каждом слиянии и итоговый отсортированный массив.
    """

    # Считываем количество элементов из первой строки
    n = int(input_lines[0])

    # Преобразуем вторую строку в список целых чисел
    arr = list(map(int, input_lines[1].split()))

    # Инициализируем список для хранения строк вывода
    output: List[str] = []

    # Запускаем сортировку слиянием
    merge_sort(arr, 0, n, output)

    # Добавляем отсортированный массив в список вывода
    output.append(" ".join(map(str, arr)))

    return output


def merge_sort(arr: List[int], l: int, r: int, output: List[str]) -> None:
    """
    Рекурсивная функция для сортировки массива с помощью сортировки слиянием.
    """

    # Проверяем, содержит ли подмассив более одного элемента
    if r - l > 1:
        # Находим середину подмассива
        m = (l + r) // 2

        # Рекурсивно сортируем левую половину
        merge_sort(arr, l, m, output)

        # Рекурсивно сортируем правую половину
        merge_sort(arr, m, r, output)

        # Сливаем отсортированные половины
        merge(arr, l, m, r, output)


def merge(arr: List[int], l: int, m: int, r: int, output: List[str]) -> None:
    """
    Сливает два отсортированных подмассива в один.
    """

    # Создаем копии левого и правого подмассивов
    left = arr[l:m]
    right = arr[m:r]

    # Инициализируем индексы для итерации по подмассивам
    i = j = 0

    # Индекс для вставки в основной массив
    k = l

    # Пока есть элементы в обоих подмассивах
    while i < len(left) and j < len(right):
        # Выбираем наименьший элемент и помещаем его в основной массив
        if left[i] <= right[j]:
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1

        k += 1

    # Копируем оставшиеся элементы из левого подмассива
    while i < len(left):
        arr[k] = left[i]
        i += 1
        k += 1

    # Копируем оставшиеся элементы из правого подмассива
    while j < len(right):
        arr[k] = right[j]
        j += 1
        k += 1

    # Подготавливаем данные для вывода информации о слиянии
    If = l + 1  # Начальный индекс области слияния (1-начало)
    Il = r  # Конечный индекс области слияния
    Vf = arr[l]  # Первый элемент после слияния
    Vl = arr[r - 1]  # Последний элемент после слияния

    # Добавляем информацию о слиянии в список вывода
    output.append(f"{If} {Il} {Vf} {Vl}")


solve(get_solution)
